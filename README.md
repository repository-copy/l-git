Это репозитарий git для тренировки работы с системой контроля версий git :)

Глобальный конфиг лежит в домашней дериктории пользователя ~/.gitconfig 

.git/config - локальный конфиг конкретного проекта

git config --global core.pager 'less -RFX' - этой командой устанавливаем, чтобы гит по умолчанию использовал программу less для показа справки. Он её и так использует, но без параметров -RFX

git show --pretty=fuller - показать подробно коммит с выведением автора кода, и того кто сделал коммит.

git add . - команда git add c точкой передает в git весь текущий каталог. 

git config --global core.excludesFile ~/.gitignore
эта команда добавляет в глобальный конфиг строку о том, что существует глобальный 
файл .gitignore в директории пользователя. Глобальный .gitignore используется для игнора например вспомогательных файлов IDE, например WebStorm создает каталог .idea для своих вспомогательных файлов. Вот её можно добавлять в глобальный .gitignore 


Правило больших описаний к коммитам: Первая строка делается короткой и без точки и после неё пустая строка. Дальше уже списком описываем все изменения в подробностях.
Пример:
1 Created welcome page
2
3 * Added feature A
4 * Fix feature B
Конец примера. Звездочки в примере ничего не значат, просто элементы форматирования. Можно использовать точки, тире и т.д. Номера 1,2,3,4 это номера строк в текстовом редакторе. Здесь я их указал, чтобы показать что после заголовка коммита на первой строке идет пустая строка.


git branch <branchname>  команда для создания новой ветки
git checkout <branchname> переключится на другую ветку. По сути эта команда обновляет ссылку ref: refs/heads/master на ref: refs/heads/<branchname> в файле HEAD
git checkout -b <branchname> создать ветку и тут же переключится на неё
git checkout -f <branchname> удалит все несохраненные (незакоммиченные) изменения в текущей ветке и переключится на новую ветку. Вызов checkout c флагом -f без указания ветки можно использовать для отмены всех незакоммиченных изменений в текущей ветке

git stash	прячет незакоммиченные изменения где-то у себя внутри. И теперь можно переключится с этой ветки на другую, используя обычную команду checkout <branchname>. В другой ветке можно что-то поделать и вернуться обратно. Теперь, чтобы вернуть изменения нужно выполнить команду git stash pop.
git stash pop	возвращает изменения, которые были спрятаны командой git stash
git stash list	показывает есть ли застэшенные данные и на какой ветке они находятся

Если мы вносим изменения в файл, который в обоих ветках одинаков и затем НЕ коммитим их и переключаемся на другую ветку командо checkout <branchname>, то гит спокойно переключится потому что ему не надо переписывать файл ибо он одинаков в обоих ветках. 

git log master..<branchname> выведет историю коммитов в ветке без коммитов унаследованных от родительской ветки master

Если, в процессе разработке мы поняли, что несколько последних коммитов в ветке master стоило бы выделить в отдельную ветку, то это можно сделать так. Сначала создаем новую ветку на текущем коммите командой git branch <имя новой ветки>. Затем либо командой git branch -f master <номер коммита откуда хотим чтобы ветка master разветвлялась>. Либо другой вариант git checkout -B master <номер коммита>.  Подробнее смотри видео 4.4 Скринкаст по Git Ильи Кантора - Передвижение веток "вручную".

git show HEAD~	показать родительский коммит HEAD. Кол-во тильд не ограничено. Для удобства их можно заменять цыфрами. Например git show HEAD~4. 
git show HEAD	сокращенно можно писать git show @ В OS Windows собачку надо брать в ковычки git show '@' 
Примеры:
git show @	покажет последний коммит
git show @~	покажет предпоследний коммит
git show @~5	покажет пятый коммит от HEAD
 
git show <номер коммита || @~n> <path>	Это команда чтобы посмотреть предедущею версию файла т.е. каким файл был во время того или иного коммита 
